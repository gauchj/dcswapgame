import random
import copy

try:
    import colorama
    colors = [
        colorama.Back.BLUE,
        colorama.Back.CYAN,
        colorama.Back.GREEN,
        colorama.Back.YELLOW,
        colorama.Back.RED,
        colorama.Back.MAGENTA
    ]
    _use_color=True
except ImportError:
    _use_color=False 

kAllFlags = 0xfff
kUnMovable = 0x001
kRoundBomb = 0x002
kHorizontalBomb = 0x004
kVerticalBomb = 0x008
kColorBomb = 0x010

kMovingUp = 0x020
kMovingRight = 0x040
kMovingDown = 0x080
kMovingLeft = 0x100
kMovingMask = (kMovingDown | kMovingLeft | kMovingRight | kMovingUp)

dirdisplay = {
    kMovingUp: 'up',
kMovingRight: 'right',
kMovingDown: 'down',
kMovingLeft: 'left'
}

def formatmoves(moves):
    res = []
    for i, j, dir in moves:
        res.append('{}, {}, {}'.format(i+1, j+1, dirdisplay[dir]))
    return '  ->  '.join(res)

class InvalidMove(Exception):
    pass

def adddir(ij, dir):
    return ij[0]+dir[0],ij[1]+dir[1]

class Tile(object):
    def __init__(self, color, modifiers):
        self.color = color
        self.modifiers = modifiers
    
    def __eq__(self, other):
        if not type(other) == type(self):
            return False
        return self.color == other.color
    @property
    def movable(self):
        return self.modifiers & kUnMovable == 0
    
    @movable.setter
    def movable(self, value):
        if not value:
            self.modifiers |= kUnMovable
        else:
            self.modifiers &= (kUnMovable ^ kAllFlags)
    
    @property
    def horizontalBomb(self):
        return self.modifiers & kHorizontalBomb

    @property
    def verticalBomb(self):
        return self.modifiers & kVerticalBomb
    
    @property
    def roundBomb(self):
        return self.modifiers & kRoundBomb
    
    @property
    def colorBomb(self):
        return self.modifiers & kColorBomb
    
    @property
    def moving(self):
        return self.modifiers & kMovingMask
    
    @moving.setter
    def moving(self, direction):
        direction = direction & kMovingMask
        self.modifiers = self.modifiers & (kAllFlags ^ kMovingMask) | direction
        
    def __str__(self):
        if not self.movable:
            return '#'
        if self.colorBomb:
            return '*'
        if not _use_color:
            return str(self.color)
        else:
            try:
                ss = [colors[self.color-1], str(self.color), colorama.Back.RESET]
                return ''.join(ss)
            except IndexError:
                return str(color)
    
    def trigger(self, board, i, j, color):
        if self.horizontalBomb:
            return [(i, k, self.color) for k in range(board.sizej)]
        if self.verticalBomb:
            return [(k, j, self.color) for k in range(board.sizei)]
        if self.roundBomb:
            todelete = []
            for ii in (i-1, i, i+1):
                if not (0 <= ii < board.sizei):
                    continue
                for jj in (j-1, j, j+1):
                    if not (0 <= jj < board.sizej):
                        continue
                    todelete.append((ii, jj, self.color))
            return todelete
        if self.colorBomb:
            todelete = []
            for ii in range(board.sizei):
                for jj in range(board.sizej):
                    if board[ii, jj].color == color:
                        todelete.append((ii, jj, color))
            return todelete

def get_strait_type(st, board):
    for ij in st:
        color = board[ij].color
        if not color == None:
            break
    else:
        color = None
    if len(st) == 3:
        return (0, color, None)
    if len(st) == 4: # can only be generated by four in a row
        for i, j in st:
            if board[i,j].moving:
                if board[i,j].moving & (kMovingDown | kMovingUp):
                    # connected four by moving vertical -> vertical bomb created
                    return (1, color, (kVerticalBomb, i, j))
                else:
                    return (1, color, (kHorizontalBomb, i, j))
        else:
            return (0, color, None) # this is a horizontal bomb, but no pieces were moving
                # we do not know where to place the bomb
    numrows = len(set(i for i, j in st))
    numcols = len(set(j for i, j in st))
    if numrows > 1 and numcols > 1: # L or T shape
        for i, j in st:
            if board[i,j].moving:
                # the first moving piece is our bomb
                return (1, color, (kRoundBomb, i, j))
        else:
            return (0, color, None) # no moving pieces
    
    # only >5 pieces in a row remain
    
    for i, j in st:
        if board[i,j].moving:
            return (1, 0, (kColorBomb, i, j))
    else:
        return (0, color, None)


class Game(object):
    def __init__(self, sizei, sizej, num_colors=4, fill_random=False):
        self.sizei = sizei
        self.sizej = sizej
        self.num_colors = num_colors
        self.fill_random = fill_random
        self.initialize()
    
    def initialize(self):
        self.b = [None]*self.sizei
        for i in range(self.sizei):
            self.b[i] = [None]*self.sizej
    
    def random(self):
        for i in range(self.sizei):
            for j in range(self.sizej):
                self.b[i][j] = Tile(random.randint(1, self.num_colors), 0)
    
    def _iterrow(self, i):
        return iter(self.b[i])
    
    def _itercolumn(self, j):
        for i in range(self.sizei):
            yield self.b[i][j]
    
    def __getitem__(self, ij):
        i, j = ij
        if not 0 <= i < self.sizei:
            raise IndexError()
        if not 0 <= j < self.sizej:
            raise IndexError()
        return self.b[i][j]
    def __setitem__(self, ij, v):
        i, j = ij
        self.b[i][j] = v
    
    def __repr__(self):
        x = []
        x.append('+')
        x.append('---+'*self.sizej)
        x.append('\n')
        for r in self.b:
            x.append('| ')
            tiles = []
            for t in r:
                if type(t) == Tile:
                    tiles.append(str(t))
                else:
                    tiles.append(' ')
            x.append(' | '.join(tiles))
            x.append(' |\n')
            x.append('+')
            x.append('---+'*self.sizej)
            x.append('\n')
        return ''.join(x)

    def get_straits(self, it):
        straits = []
        I = enumerate(it)
        i, last = next(I)
        for j, cur in I:
            if last == cur:
                last = cur
            else:
                if i < j-2 and last != None and last.movable:
                    straits.append((i,j))
                i = j
                last = cur
        if i < j-1 and last != None and last.movable:
            straits.append((i, j+1))
        return straits
    
    def find_to_remove(self):
        rowstraits = [self.get_straits(self._iterrow(i)) for i in range(self.sizei)]
        colstraits = [self.get_straits(self._itercolumn(j)) for j in range(self.sizej)]
        
        bitmap = [[0 for j in range(self.sizej)] for i in range(self.sizei)]
        horizstraits = []
        for i, s in enumerate(rowstraits):
            for start, stop in s:
                st = []
                for k in range(start, stop):
                    bitmap[i][k] = 1
                    st.append((i, k))
                horizstraits.append(set(st))
        allstraits = []
        for j, s in enumerate(colstraits):
            for start, stop in s:
                st = []
                interesting = False
                for k in range(start, stop):
                    bitmap[k][j] += 1
                    if bitmap[k][j] > 1:
                        interesting = True
                    st.append((k, j))
                st = set(st)
                if not interesting:
                    allstraits.append(st)
                else:
                    intersections = []
                    for i, h in enumerate(horizstraits):
                        if st.intersection(h):
                            intersections.append(i)
                    for i in reversed(intersections):
                        h = horizstraits.pop(i)
                        st = st.union(h)
                    allstraits.append(st)
        allstraits.extend(horizstraits)
        return bitmap, allstraits
    
    
    
    def anneal_step_remove(self, trigger=None):
        bitmap, allstraits = self.find_to_remove()
        removedpieces = []
        triggered = set()
        totrigger = set()
        tocreate = list()
        
        if trigger:
            totrigger.add(trigger)
        
        for s in allstraits:
            added_pieces, color, infos = get_strait_type(s, self)
            if added_pieces:
                type, i, j = infos
                piece = Tile(color, type)
                tocreate.append((i, j, piece))
            totrigger.update((ii, jj, color) for ii,jj in s)
        
        while totrigger:
            ttnew = set()
            for ijc in totrigger:
                try:
                    trigs = self[ijc[:2]].trigger(self, *ijc)
                    triggered.add(ijc)
                    removedpieces.append(self[ijc[:2]])
                    if trigs:
                        ttnew.update(trigs)
                except AttributeError:
                    triggered.add(ijc)
            totrigger = ttnew.difference(triggered)
            
        for ij in triggered:
            self[ij[:2]] = None
        
        for i, j, tile in tocreate:
            self[i, j] = tile
        
        return removedpieces, triggered, allstraits, tocreate
    
    def anneal_step_drop(self):
        for i in reversed(range(self.sizei)):
            for j in range(self.sizej):
                if self[i,j] is None:
                    for ii in range(i-1, -1, -1):
                        if self[ii, j] is not None:
                            if not self[ii,j].movable:
                                continue
                            self[i,j] = self[ii, j]
                            self[ii, j] = None
                            self[i,j].moving = kMovingDown
                            break
                    else: # no non-empty fields above
                        if self.fill_random:
                            self[i,j] = Tile(random.randint(1, self.num_colors), kMovingDown)
    
    def anneal(self):
        removedpieces = []
        newremovedpieces, _, _, _ = self.anneal_step_remove()
        while newremovedpieces:
            removedpieces.extend(newremovedpieces)
            self.anneal_step_drop()
            newremovedpieces, _, _, _ = self.anneal_step_remove()
        for i in range(self.sizei):
            for j in range(self.sizej):
                try:
                    self[i,j].moving=0
                except AttributeError:
                    pass
        return removedpieces
        
    def _move(self, i, j, direction):
        k, l, otherdir = self.movetarget(i, j, direction)
        
        self[i,j], self[k, l] = self[k, l], self[i,j]
        self[i,j].moving = otherdir
        self[k,l].moving = direction
    
    def movetarget(self, i, j, direction):
        if direction == kMovingRight:
            k, l = i, j+1
            otherdir = kMovingLeft
        elif direction == kMovingLeft:
            k, l = i, j-1
            otherdir = kMovingRight
        elif direction == kMovingUp:
            k, l = i-1, j
            otherdir = kMovingDown
        elif direction == kMovingDown:
            k, l = i+1, j
            otherdir = kMovingUp
        
        if not 0 <= k < self.sizei \
            or not 0 <= l < self.sizej:
            raise InvalidMove('invalid move outside the board')
        if not self[i,j].movable or not self[k, l].movable:
            raise InvalidMove('invalid move of fixed tile')
        
        return k, l, otherdir
    
    def check_valid_move(self, i, j, direction):
        try:
            k, l, otherdir = self.movetarget(i, j, direction)
        except InvalidMove:
            return False
        except AttributeError:
            return False
        
        movingtile = self[i, j]
        
        if movingtile.colorBomb:
            return True
        
#            # # # # # # #
#            # # # b # # #
#            # # # bd# # #
#                ->X a a #
#            # # # cd# # #
#            # # # c # # #
#            # # # # # # #

#           points:
#           +dir, +2dir
#           +ldir, +2lidr
#           -ldir, -2ldir
#           +ldir, -ldir

        def iter_check_points(kl, direction):
            up = (-1, 0)
            down = (1, 0)
            left = (0, -1)
            right = (0, 1)
            dir, ldir, rdir = {
                kMovingUp: (up, left, right),
                kMovingRight: (right, up, down),
                kMovingDown: (down, right, left),
                kMovingLeft: (left, down, up)
            }[direction]
            a = adddir(kl, dir)
            b = adddir(a, dir)
            yield a, b
            a = adddir(kl, ldir)
            b = adddir(a, ldir)
            yield a, b
            b = adddir(kl, rdir)
            yield a, b
            a = adddir(b, rdir)
            yield a, b 
        
        # print('my tile is {}'.format(movingtile))
        for a, b in iter_check_points((k, l), direction):
            try:
                # print('checking {}: {}'.format(a, self[a]))
                if not movingtile == self[a]:
                    # print('continuing')
                    continue
                # print('checking {}: {}'.format(b, self[b]))
                if movingtile == self[b]:
                    # print('found')
                    return True
            except Exception as E:
                # print('failed... exception = {}'.format(E))
                pass
            # print('continuing')

        else:
            return False
    
    def find_all_moves(self):
        moves = []
        for i in range(self.sizei):
            for j in range(self.sizej):
                if not self[i,j] or not self[i,j].movable:
                    continue
                for dir in (kMovingDown, kMovingUp, kMovingLeft, kMovingRight):
                    if self.check_valid_move(i, j, dir):
                        moves.append((i, j, dir))
        return moves
    
    def move(self, i, j, direction):
        X = copy.deepcopy(self)
        X._move(i, j, direction)
        k, l, otherdir = self.movetarget(i, j, direction)
        
        removed = X.anneal()
        return X, removed
    
    def evaluate_all_moves(self, evaluator=None):
        return self.evaluate_moves(self.allmoves(), evaluator)
    
    def evaluate_moves(self, moves, evaluator=None, do_print=False):
        results = []
        for move, X, removed in moves:
            if evaluator:
                score = evaluator(X, removed, move)
            else:
                score = len(removed)
            results.append((score, move))
        results.sort()
        
        if do_print:
            for score, move in results:
                print('{}\t{}'.format(score, formatmoves(move)))
        return results
        
    def evaluate_multilevel(self, evaluator, do_print=False, max_level=3):
        mulmoves = self.find_multilevel_moves(max_level)
        results = self.evaluate_moves(mulmoves, evaluator, do_print)
        return mulmoves, results
    
    def allmoves(self):
        results = []
        for move in self.find_all_moves():
            X, removed = self.move(*move)
            results.append(((move,), X, removed))
        return results
    
    
    def find_multilevel_moves(self, maxlevel=3):
        levelmoves = [self.allmoves()]
        
        def get_next_level_moves(l1m):
            nlm = []
            for mov1, X1, rem1 in l1m:
                for mov2, X2, rem2 in X1.allmoves():
                    mov = mov1 + mov2
                    rem = rem1 + rem2
                    nlm.append((mov, X2, rem))
            return nlm
        allmoves = levelmoves[0]
        for x in range(maxlevel):
            levelmoves.append(get_next_level_moves(levelmoves[-1]))
            allmoves += levelmoves[-1]
        
        return allmoves
        
importtable =  {
-1: {'c': 0, 'modifiers': kUnMovable},
 1: {'c': 5, 'color': 'red', 'modifiers': 0},
 2: {'c': 5, 'color': 'red', 'modifiers': 4},
 3: {'c': 5, 'color': 'red', 'modifiers': 8},
 4: {'c': 5, 'color': 'red', 'modifiers': 2},
 5: {'c': 3, 'color': 'green', 'modifiers': 0},
 6: {'c': 3, 'color': 'green', 'modifiers': 4},
 7: {'c': 3, 'color': 'green', 'modifiers': 8},
 8: {'c': 3, 'color': 'green', 'modifiers': 2},
 9: {'c': 4, 'color': 'yellow', 'modifiers': 0},
 10: {'c': 4, 'color': 'yellow', 'modifiers': 4},
 11: {'c': 4, 'color': 'yellow', 'modifiers': 8},
 12: {'c': 4, 'color': 'yellow', 'modifiers': 2},
 13: {'c': 1, 'color': 'blue', 'modifiers': 0},
 14: {'c': 1, 'color': 'blue', 'modifiers': 4},
 15: {'c': 1, 'color': 'blue', 'modifiers': 8},
 16: {'c': 1, 'color': 'blue', 'modifiers': 2},
 17: {'c': 2, 'color': 'orange', 'modifiers': 0},
 18: {'c': 2, 'color': 'orange', 'modifiers': 4},
 19: {'c': 2, 'color': 'orange', 'modifiers': 8},
 20: {'c': 2, 'color': 'orange', 'modifiers': 2},
 21: {'c': 6, 'color': 'purple', 'modifiers': 0},
 22: {'c': 6, 'color': 'purple', 'modifiers': 4},
 23: {'c': 6, 'color': 'purple', 'modifiers': 8},
 24: {'c': 6, 'color': 'purple', 'modifiers': 2},
 25: {'c': 0, 'color': 'clear_color', 'modifiers': 16}}
 
import urllib.parse
import json 
def fruitisland(data):
    boards = []
    data = json.loads(urllib.parse.unquote(data)[65:])
    data['commands'].sort(key=lambda c: -c['time'])
    for cmd in data['commands']:
        if not cmd['cmd'] == 'puzzle_island_move':
            continue
        boards.append((cmd['time'], import_fruitisland(cmd['args'])))
    return boards
 
def import_fruitisland(args):
    board = args[4]
    B = Game(9, 9)
    boardit = sum(board, [])
    ii = iter(boardit)
    for j in range(9):
        for i in range(9):
            tt = next(ii)
            ttt = importtable[tt]
            T = Tile(ttt['c'], ttt['modifiers'])
            B[i,j] = T
    return B
 
[1,
 [[6, 6], [5, 6]],
 [17, 17, 17, 17, 5, 5, 5],
 2,
 [[-1, -1, 9, 5, 21, 13, 9, -1, -1],
  [-1, -1, 1, 1, 5, 13, 21, -1, -1],
  [1, 9, 5, 13, 21, 21, 9, 5, 21],
  [17, 13, 5, 17, 21, 1, 1, 5, 13],
  [1, 17, 1, 1, 9, 5, 1, 17, 13],
  [9, 9, 5, 13, 21, 13, 13, 5, 19],
  [5, 13, 9, 5, 1, 9, 13, 21, 9],
  [-1, -1, 1, 21, 9, 1, 5, -1, -1],
  [-1, -1, 1, 9, 21, 5, 9, -1, -1]]]
